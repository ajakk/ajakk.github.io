diff --git a/faxd/Class1.c++ b/faxd/Class1.c++
index 62eb7bc..f623f1d 100644
--- a/faxd/Class1.c++
+++ b/faxd/Class1.c++
@@ -1673,7 +1673,7 @@ Class1Modem::transmitData(int br, u_char* data, u_int cc,
  * retransmit the frame. 
  */
 bool
-Class1Modem::recvFrame(HDLCFrame& frame, u_char dir, long ms, bool readPending, bool docrp, bool usehooksensitivity)
+Class1Modem::recvFrame(HDLCFrame& frame, u_char dir, long ms, bool readPending, bool docrp, bool usehooksensitivity, u_int echofcf)
 {
     bool gotframe;
     u_short crpcnt = 0, rhcnt = 0;
@@ -1736,8 +1736,10 @@ Class1Modem::recvFrame(HDLCFrame& frame, u_char dir, long ms, bool readPending,
             return (false);
         }
 	fxStr emsg;
+	bool gotecho = false;
 	do {
-	    if (crpcnt || rhcnt) {
+	    if (crpcnt || rhcnt || gotecho) {
+		if (gotecho) gotecho = false; // reset
 		if (rhcnt) crpcnt = 0;
 		if (crpcnt) {
 		    rhcnt = 0;
@@ -1779,6 +1781,12 @@ Class1Modem::recvFrame(HDLCFrame& frame, u_char dir, long ms, bool readPending,
 	    }
 	    frame.reset();
             gotframe = recvRawFrame(frame);
+	    if (echofcf && gotframe && frame.getFCF() == echofcf) {
+		traceFCF(dir == FCF_SNDR ? "SEND echo" : "RECV echo", echofcf);
+		gotecho = true;
+		gotframe = false;
+		echofcf = 0;	// only expect one possible echo
+	    }
 	    /*
 	     * Some modems aren't very particular about reporting CONNECT after AT+FRH=3.
 	     * So, for such modems CONNECT may come with V.17 modulated audio or any noise
@@ -1789,6 +1797,7 @@ Class1Modem::recvFrame(HDLCFrame& frame, u_char dir, long ms, bool readPending,
 	     */
 	} while (((u_int) Sys::now()-start < howmany(conf.t1Timer, 1000)) && !gotframe && !wasTimeout() && 
 	    ((conf.class1HasRHConnectBug && !frame.getLength() && lastResponse == AT_NOCARRIER && rhcnt++ < 30) ||
+	    gotecho ||
 	    (docrp && crpcnt++ < 3 && switchingPause(emsg, 3) && transmitFrame(dir|FCF_CRP))));	/* triple switchingPause to avoid sending CRP during TCF */
 	return (gotframe);
     } else {
diff --git a/faxd/Class1.h b/faxd/Class1.h
index 781b15e..d5215c7 100644
--- a/faxd/Class1.h
+++ b/faxd/Class1.h
@@ -70,6 +70,8 @@ protected:
     bool	jbigSupported;		// whether or not JBIG is supported in this mode
     bool	senderHasV17Trouble;	// whether or not a sender has trouble with V.17
     bool	senderSkipsV29;		// whether or not a sender skips over V.29 usage
+    bool	senderConfusesRTN;	// whether or not a sender properly handles RTN
+    bool	sentRTN;		// whether or not we recently sent RTN
     int		dataSent;		// how much data the sender transmitted
     int		dataMissed;		// how much data from the sender was missed
     int		pageDataMissed;		// how much data from the sender was missed on this page
@@ -221,7 +223,7 @@ protected:
     bool	sendClass1Data(const u_char* data, u_int cc, const u_char* bitrev, bool eod, long ms);
     bool	sendClass1ECMData(const u_char* data, u_int cc,
 		     const u_char* bitrev, bool eod, u_int ppmcmd, fxStr& emsg);
-    bool	recvFrame(HDLCFrame& frame, u_char dir, long ms = 10*1000, bool readPending = false, bool docrp = true, bool usehooksensitivity = true);
+    bool	recvFrame(HDLCFrame& frame, u_char dir, long ms = 10*1000, bool readPending = false, bool docrp = true, bool usehooksensitivity = true, u_int echofcf = 0);
     bool	recvTCF(int br, HDLCFrame&, const u_char* bitrev, long ms);
     bool	recvRawFrame(HDLCFrame& frame);
     bool	recvECMFrame(HDLCFrame& frame);
diff --git a/faxd/Class1Recv.c++ b/faxd/Class1Recv.c++
index b6752e9..8b667dd 100644
--- a/faxd/Class1Recv.c++
+++ b/faxd/Class1Recv.c++
@@ -101,9 +101,12 @@ Class1Modem::recvBegin(FaxSetup* setupinfo, fxStr& emsg)
     dataMissed = 0;				// unfortunately, this will reset after EOM
     pageDataMissed = 0;
     senderSkipsV29 = false;
+    senderConfusesRTN = false;
     senderHasV17Trouble = false;
+    sentRTN = false;
 
     if (setupinfo) {
+	senderConfusesRTN = setupinfo->senderConfusesRTN;
 	senderSkipsV29 = setupinfo->senderSkipsV29;
 	senderHasV17Trouble = setupinfo->senderHasV17Trouble;
     }
@@ -141,6 +144,7 @@ Class1Modem::recvBegin(FaxSetup* setupinfo, fxStr& emsg)
 	/*
 	 * Update FaxMachine info...
 	 */
+	setupinfo->senderConfusesRTN = senderConfusesRTN;
 	setupinfo->senderSkipsV29 = senderSkipsV29;
 	setupinfo->senderHasV17Trouble = senderHasV17Trouble;
 	setupinfo->senderDataSent = dataSent;
@@ -255,6 +259,10 @@ Class1Modem::recvIdentification(
 			if (!recvDCSFrames(frame)) {
 			    switch (frame.getFCF()) {
 				case FCF_DCN:
+				    if (sentRTN && curcap->br != BR_2400) {
+					protoTrace("This sender appears to not respond properly to RTN.");
+					senderConfusesRTN = true;
+				    }
 				    emsg = "RSPREC error/got DCN (sender abort) {E103}";
 				    recvdDCN = true;
 				    return (false);
@@ -405,6 +413,7 @@ Class1Modem::recvDCSFrames(HDLCFrame& frame)
 	case FCF_DCS:
 	    if (frame.getFrameDataLength() < 4) return (false);	// minimum acceptable DCS frame size
 	    processDCSFrame(frame);
+	    sentRTN = false;	// reset it, the sender appears to have behaved appropriately
 	    break;
 	case FCF_DCN:
 	    gotEOT = true;
@@ -669,6 +678,7 @@ Class1Modem::recvPage(TIFF* tif, u_int& ppm, fxStr& emsg, const fxStr& id, u_int
 	    startTimeout(7550);
 	    (void) sendFrame(FCF_RTN|FCF_RCVR);
 	    stopTimeout("sending HDLC frame");
+	    sentRTN = true;
 	    FaxParams dis = modemDIS();
 	    if (!recvIdentification(0, fxStr::null, 0, fxStr::null, 
 		0, fxStr::null, 0, fxStr::null, 0, dis,
@@ -871,16 +881,23 @@ Class1Modem::recvPage(TIFF* tif, u_int& ppm, fxStr& emsg, const fxStr& id, u_int
 				signalRcvd = frame.getFCF();
 				messageReceived = true;
 			    } else {
-				/*
-				 * V.21 HDLC was detected and then the carrier was lost without
-				 * receiving any data.  It's possible that the modem erred in 
-				 * its detection of the high-speed carrier.  But, it's also 
-				 * possible that echo of our CFR was detected or that there is 
-				 * another receiver on the line (another fax machine sharing the 
-				 * line on the send-side), and we heard them.  Often we can still 
-				 * acquire the high-speed carrier if we just re-issue AT+FRM=n.
-				 */
-				if (lastResponse == AT_NOCARRIER) retryrmcmd = true;
+				if (lastResponse == AT_NOCARRIER) {
+				    /*
+				     * V.21 HDLC was detected and then the carrier was lost without
+				     * receiving any data.  It's possible that the modem erred in
+				     * its detection of the high-speed carrier.  But, it's also
+				     * possible that echo of our CFR was detected or that there is
+				     * another receiver on the line (another fax machine sharing the
+				     * line on the send-side), and we heard them.  Often we can still
+				     * acquire the high-speed carrier if we just re-issue AT+FRM=n.
+				     */
+				    retryrmcmd = true;
+				} else {
+				    /*
+				     * The frame data was corrupt.
+				     */
+				    signalRcvd = 0;
+				}
 			    }
 			}
 		    }
@@ -902,20 +919,19 @@ Class1Modem::recvPage(TIFF* tif, u_int& ppm, fxStr& emsg, const fxStr& id, u_int
 		     *   the message data, or there was a timeout waiting
 		     *   for the carrier to drop.
 		     */
-		    if (!wasTimeout()) {
+		    if (wasTimeout()) {
 			/*
-			 * We found the wrong carrier, which means that there
-			 * is an HDLC frame waiting for us--in which case it
-			 * should get picked up below.
+			 * The timeout expired - thus we missed the carrier either
+			 * raising or dropping.
 			 */
+			abortReceive();		// return to command state
 			break;
 		    }
 		    /*
-		     * The timeout expired - thus we missed the carrier either
-		     * raising or dropping.
+		     * We found the wrong carrier, which means that there
+		     * is an HDLC frame waiting for us--in which case it
+		     * should get picked up below.
 		     */
-		    abortReceive();		// return to command state
-		    break;
 		} else {
 		    /*
 		     * Some modems respond ERROR instead +FCERROR on wrong carrier
@@ -949,7 +965,6 @@ Class1Modem::recvPage(TIFF* tif, u_int& ppm, fxStr& emsg, const fxStr& id, u_int
 	    for (u_int i = 0; i < frameRcvd.length(); i++) frame.put(frameRcvd[i]);
 	    frame.setOK(true);
 	} else {
-	    gotCONNECT = false;
 	    u_short recvFrameCount = 0;
 	    time_t ppmstart = Sys::now();
 	    do {
@@ -960,7 +975,7 @@ Class1Modem::recvPage(TIFF* tif, u_int& ppm, fxStr& emsg, const fxStr& id, u_int
 		 * occurs a bit more tolerance here...
 		 */
 		ppmrcvd = recvFrame(frame, FCF_RCVR, timer);
-	    } while (!ppmrcvd && gotCONNECT && wasTimeout() && !gotEOT && ++recvFrameCount < 3);
+	    } while (!ppmrcvd && gotCONNECT && !wasTimeout() && !gotEOT && ++recvFrameCount < 3);
 	    if (ppmrcvd) lastPPM = frame.getFCF();
 	    /*
 	     * To combat premature carrier loss leading to MCF instead of RTN on short/partial pages,
@@ -989,6 +1004,7 @@ Class1Modem::recvPage(TIFF* tif, u_int& ppm, fxStr& emsg, const fxStr& id, u_int
 	    case FCF_TSI:
 	    case FCF_DCS:
 		{
+		    sentRTN = false;	// reset it, the sender appears to have behaved appropriately
 		    signalRcvd = 0;
 		    if (!pageGood) recvResetPage(tif);
 		    // look for high speed carrier only if training successful
@@ -1123,6 +1139,10 @@ Class1Modem::recvPage(TIFF* tif, u_int& ppm, fxStr& emsg, const fxStr& id, u_int
 						    emsg = "COMREC received DCN (sender abort) {E108}";
 						    gotEOT = true;
 						    recvdDCN = true;
+						    if (sentRTN && curcap->br != BR_2400) {
+							protoTrace("This sender appears to not respond properly to RTN.");
+							senderConfusesRTN = true;
+						    }
 						} else if (params.ec != EC_DISABLE && rrframe.getFCF() != FCF_RR) {
 						    protoTrace("Ignoring invalid response to RNR.");
 						}
@@ -1212,20 +1232,59 @@ Class1Modem::recvPage(TIFF* tif, u_int& ppm, fxStr& emsg, const fxStr& id, u_int
 			return (false);
 		    }
 		    signalRcvd = 0;
-		    if (params.ec == EC_DISABLE && rmResponse != AT_CONNECT && !getRecvEOLCount() && (Sys::now() - lastMCF < 9)) {
-			/*
-			 * We last transmitted MCF a very, very short time ago, received no image data
-			 * since then, and now we're seeing a PPM again.  In non-ECM mode the chances of 
-			 * this meaning that we simply missed a very short page is extremely remote.  It
-			 * probably means that the sender did not properly hear our MCF and that we just
-			 * need to retransmit it. 
-			 */
-			(void) transmitFrame(FCF_MCF|FCF_RCVR);
-			traceFCF("RECV send", FCF_MCF);
-			lastMCF = Sys::now();
-			messageReceived = (lastPPM != FCF_MPS);	// expect Phase C if MPS
+		    if (params.ec == EC_DISABLE && rmResponse != AT_CONNECT && !getRecvEOLCount()) {
+			if (Sys::now() - lastMCF < 9) {
+			    /*
+			     * We last transmitted MCF a very, very short time ago, received no image data
+			     * since then, and now we're seeing a PPM again.  In non-ECM mode the chances of
+			     * this meaning that we simply missed a very short page are extremely remote.  It
+			     * probably means that the sender did not properly hear our MCF and that we just
+			     * need to retransmit it.
+			     */
+			    (void) transmitFrame(FCF_MCF|FCF_RCVR);
+			    traceFCF("RECV send", FCF_MCF);
+			    lastMCF = Sys::now();
+			    messageReceived = (lastPPM != FCF_MPS);	// expect Phase C if MPS
+			} else {
+			    /*
+			     * We missed training on the Phase C carrier, and so we missed the Phase C image data.
+			     * T.30 (Figure 5-2c in 09/2005 T.30) makes it clear with "CAPABLE RE-XMIT" that RTN
+			     * should not be interpreted as receipt confirmation.  Senders who are not capable of
+			     * retransmitting should respond to RTN with DCN.  So, it is unfortunate that there are
+			     * some senders out there which interpret RTN as a receipt confirmation.  Our options,
+			     * therefore, are limited.  We can send RTN, and senders who properly follow T.30 should
+			     * retransmit the page, but this will be perceived as a message confirmation by those
+			     * bothersome RTN-confused senders.  If we send DCN then we certainly get the message
+			     * accross about no receipt confirmation, but we risk the sender not calling back, and
+			     * we miss the real likelihood that the sender could have retransmitted in the same call.
+			     * Another option we have is to send an out-of-spec CFR signal which senders will not
+			     * perceive as receipt confirmation, but unless the sender handles this Phase B signal
+			     * while in Phase D (and HylaFAX may be the only one that does) this will lead to the
+			     * sender disconnecting.  Having this decision as configurable allows the administrator
+			     * to adjust with DynamicConfig or something, if needed.
+			     */
+			    if (senderConfusesRTN || conf.missedPageHandling == FaxModem::MISSEDPAGE_DCN) {
+				emsg = "PPM received with no image data.  To continue risks receipt confirmation. {E155}";
+				(void) transmitFrame(FCF_DCN|FCF_RCVR);
+				traceFCF("RECV send", FCF_DCN);
+				recvdDCN = true;
+				return (false);
+			    }
+			    protoTrace("Phase C data was missed.  Attempt to get the sender to retransmit.");
+			    if (conf.missedPageHandling == FaxModem::MISSEDPAGE_CFR) {
+				(void) transmitFrame(FCF_CFR|FCF_RCVR);
+				traceFCF("RECV send", FCF_CFR);
+				messageReceived = false;	// stay in Phase C
+			    } else {	// MISSEDPAGE_RTN
+				(void) transmitFrame(FCF_RTN|FCF_RCVR);
+				traceFCF("RECV send", FCF_RTN);
+				messageReceived = true;		// return to Phase B
+				sentRTN = true;
+			    }
+			}
 		    } else {
 			u_int rtnfcf = FCF_RTN;
+			sentRTN = true;
 			if (!getRecvEOLCount() || conf.badPageHandling == FaxModem::BADPAGE_DCN) {
 			    /*
 			     * Regardless of the BadPageHandling setting, if we get no page image data at
@@ -1234,6 +1293,7 @@ Class1Modem::recvPage(TIFF* tif, u_int& ppm, fxStr& emsg, const fxStr& id, u_int
 			     */
 			    emsg = "PPM received with no image data.  To continue risks receipt confirmation. {E155}";
 			    rtnfcf = FCF_DCN;
+			    sentRTN = false;
 			}
 			(void) transmitFrame(rtnfcf|FCF_RCVR);
 			traceFCF("RECV send", rtnfcf);
@@ -1267,6 +1327,10 @@ Class1Modem::recvPage(TIFF* tif, u_int& ppm, fxStr& emsg, const fxStr& id, u_int
 		protoTrace("RECV recv DCN");
 		emsg = "COMREC received DCN (sender abort) {E108}";
 		recvdDCN = true;
+		if (sentRTN && curcap->br != BR_2400) {
+		    protoTrace("This sender appears to not respond properly to RTN.");
+		    senderConfusesRTN = true;
+		}
 		if (prevPage && conf.saveUnconfirmedPages && getRecvEOLCount()) {	// only if there was data
 		    TIFFWriteDirectory(tif);
 		    protoTrace("RECV keeping unconfirmed page");
@@ -2312,6 +2376,7 @@ Class1Modem::recvEnd(FaxSetup* setupinfo, fxStr& emsg)
 	/*
 	 * Update FaxMachine info...
 	 */
+	setupinfo->senderConfusesRTN = senderConfusesRTN;
 	setupinfo->senderSkipsV29 = senderSkipsV29;
 	setupinfo->senderHasV17Trouble = senderHasV17Trouble;
 	setupinfo->senderDataSent = dataSent;
diff --git a/faxd/Class1Send.c++ b/faxd/Class1Send.c++
index dffe30e..d96dbcf 100644
--- a/faxd/Class1Send.c++
+++ b/faxd/Class1Send.c++
@@ -595,7 +595,6 @@ Class1Modem::sendPhaseB(TIFF* tif, Class2Params& next, FaxMachineInfo& info,
                     emsg = "Unable to transmit page (giving up after 3 attempts) {E131}";
 		    protoTrace(emsg);
                     return (send_retry);
-
                 }
 		params.br = (u_int) -1;	// force training
 		if (!dropToNextBR(next)) {
@@ -614,6 +613,21 @@ Class1Modem::sendPhaseB(TIFF* tif, Class2Params& next, FaxMachineInfo& info,
 		    return (send_retry);
 		}
 		break;
+	    case FCF_CFR:
+		/*
+		 * CFR is out of spec for Phase D.  However, its use would seem to indicate that the receiver
+		 * wants us to repeat this iteration of Phase C.  Presumably this will be done by a receiver
+		 * that did not train on the Phase C data signal but knew that the call was not hung up, so waited
+		 * for the previous iteration of Phase C to end, and repeated CFR in an effort for us to repeat.
+		 */
+		protoTrace("Apparent out-of-spec attempt to get us to retransmit the page.");
+		morePages = true;	// retransmit page
+		if (++ntrys > 2) {
+                    emsg = "Unable to transmit page (giving up after 3 attempts) {E131}";
+		    protoTrace(emsg);
+                    return (send_retry);
+		}
+		break;
 	    default:			// unexpected abort
 		emsg = "Fax protocol error (unknown frame received) {E134}";
 		protoTrace(emsg);
@@ -1427,21 +1441,16 @@ Class1Modem::blockFrame(const u_char* bitrev, bool lastframe, u_int ppmcmd, fxSt
 		// a "RESPONSE REC" operation, anyway, this is correct behavior.
 		//
 		// We don't use CRP here, because it isn't well-received.
-		do {
-		    gotppr = recvFrame(pprframe, FCF_SNDR, conf.t4Timer, false, false);
-		} while (pprframe.getFCF() == FCF_PPS && crpcnt++ < 3);		// handle echo of our PPS
+		gotppr = recvFrame(pprframe, FCF_SNDR, conf.t4Timer, false, false, true, FCF_PPS);
 		if (gotppr) {
 		    traceFCF("SEND recv", pprframe.getFCF());
 		    if (pprframe.getFCF() == FCF_CRP) {
 			gotppr = false;
 			crpcnt++;
 			ppscnt = 0;
-			if (!switchingPause(emsg)) {
-			    return (false);
-			}
 		    }
 		}
-	    } while (!gotppr && (++ppscnt < 3) && (crpcnt < 3) && !(useV34 && gotEOT));
+	    } while (!gotppr && (++ppscnt < 3) && (crpcnt < 3) && !(useV34 && gotEOT) && switchingPause(emsg));
 	    if (gotppr) {
 		if (!switchingPause(emsg)) {
 		    return (false);
@@ -1468,7 +1477,7 @@ Class1Modem::blockFrame(const u_char* bitrev, bool lastframe, u_int ppmcmd, fxSt
 			    stopTimeout("sending RR frame");
 			    traceFCF("SEND send", FCF_RR);
 			    // T.30 states that we must wait no more than T4 between unanswered RR signals.
-			    gotmsg = recvFrame(pprframe, FCF_SNDR, conf.t4Timer, false, false);
+			    gotmsg = recvFrame(pprframe, FCF_SNDR, conf.t4Timer, false, false, true, FCF_RR);
 			    if (gotmsg) {	// no CRP, stick to RR only
 				traceFCF("SEND recv", pprframe.getFCF());
 				if (pprframe.getFCF() == FCF_CRP) {
@@ -1599,7 +1608,7 @@ Class1Modem::blockFrame(const u_char* bitrev, bool lastframe, u_int ppmcmd, fxSt
 				    sendFrame(FCF_CTC|FCF_SNDR, fxStr(ctc, 2));
 				    stopTimeout("sending CTC frame");
 				    traceFCF("SEND send", FCF_CTC);
-				    gotctr = recvFrame(ctrframe, FCF_SNDR, conf.t4Timer);
+				    gotctr = recvFrame(ctrframe, FCF_SNDR, conf.t4Timer, false, true, true, FCF_CTC);
 				    if (gotctr) {
 					traceFCF("SEND recv", ctrframe.getFCF());
 					if (ctrframe.getFCF() == FCF_CRP) {
@@ -1695,7 +1704,7 @@ Class1Modem::blockFrame(const u_char* bitrev, bool lastframe, u_int ppmcmd, fxSt
 					    stopTimeout("sending RR frame");
 					    traceFCF("SEND send", FCF_RR);
 					    // T.30 states that we must wait no more than T4 between unanswered RR signals.
-					    gotmsg = recvFrame(errframe, FCF_SNDR, conf.t4Timer, false, false);
+					    gotmsg = recvFrame(errframe, FCF_SNDR, conf.t4Timer, false, false, true, FCF_RR);
 					    if (gotmsg) {	// no CRP, stick to RR only
 						traceFCF("SEND recv", errframe.getFCF());
 						if (errframe.getFCF() == FCF_CRP) {
@@ -2287,12 +2296,7 @@ Class1Modem::sendPPM(u_int ppm, HDLCFrame& mcf, fxStr& emsg)
 	traceFCF("SEND send", ppm);
 	// don't use CRP here because it isn't well-received
 	if (transmitFrame(ppm|FCF_SNDR)) {
-	    bool ok = recvFrame(mcf, FCF_SNDR, conf.t4Timer, false, false);
-	    if (ok && mcf.getFCF() == ppm) {
-		// We probably heard our own echo.  Listen again...
-		ok = recvFrame(mcf, FCF_SNDR, conf.t4Timer, false, false);
-	    }
-	    if (ok) return (true);
+	    if (recvFrame(mcf, FCF_SNDR, conf.t4Timer, false, false, true, ppm)) return (true);
 	}
 	if (abortRequested())
 	    return (false);
diff --git a/faxd/FaxMachineInfo.c++ b/faxd/FaxMachineInfo.c++
index efa5194..b652803 100644
--- a/faxd/FaxMachineInfo.c++
+++ b/faxd/FaxMachineInfo.c++
@@ -62,6 +62,7 @@ FaxMachineInfo::FaxMachineInfo(const FaxMachineInfo& other)
     hasV34Trouble = other.hasV34Trouble;
     hasV17Trouble = other.hasV17Trouble;
     senderHasV17Trouble = other.senderHasV17Trouble;
+    senderConfusesRTN = other.senderConfusesRTN;
     senderSkipsV29 = other.senderSkipsV29;
     senderDataSent = other.senderDataSent;
     senderDataSent1 = other.senderDataSent1;
@@ -125,6 +126,7 @@ FaxMachineInfo::resetConfig()
     hasV17Trouble = false;		// assume no problems
     senderHasV17Trouble = false;	// assume no problems
     senderSkipsV29 = false;		// assume V.29 usage
+    senderConfusesRTN = false;		// assume RTN sanity
     senderDataSent = 0;			// clean slate
     senderDataSent1 = 0;		// clean slate
     senderDataSent2 = 0;		// clean slate
@@ -216,6 +218,7 @@ static const char* stnames[] =
 #define SDM	15
 #define DS	16
 #define DM	17
+#define SCRTN	18
 
 #define	setLocked(b,ix)	locked |= b<<ix
 
@@ -248,6 +251,9 @@ FaxMachineInfo::setConfigItem(const char* tag, const char* value)
     } else if (streq(tag, "senderskipsv29")) {
 	senderSkipsV29 = getBoolean(value);
 	setLocked(b, SSV29);
+    } else if (streq(tag, "senderconfusesrtn")) {
+	senderConfusesRTN = getBoolean(value);
+	setLocked(b, SCRTN);
     } else if (streq(tag, "senderdatasent")) {
 	senderDataSent = getNumber(value);
 	setLocked(b, SDS);
@@ -388,6 +394,8 @@ void FaxMachineInfo::setSenderHasV17Trouble(bool b)
     { checkLock(SV17, senderHasV17Trouble, b); }
 void FaxMachineInfo::setSenderSkipsV29(bool b)
     { checkLock(SSV29, senderSkipsV29, b); }
+void FaxMachineInfo::setSenderConfusesRTN(bool b)
+    { checkLock(SCRTN, senderConfusesRTN, b); }
 void FaxMachineInfo::setSupportsPostScript(bool b)
     { checkLock(PS, supportsPostScript, b); }
 void FaxMachineInfo::setSupportsBatching(bool b)
@@ -493,6 +501,7 @@ FaxMachineInfo::writeConfig(fxStackBuffer& buf)
     putBoolean(buf, "hasV17Trouble", isLocked(V17),hasV17Trouble);
     putBoolean(buf, "senderHasV17Trouble", isLocked(SV17),senderHasV17Trouble);
     putBoolean(buf, "senderSkipsV29", isLocked(SSV29), senderSkipsV29);
+    putBoolean(buf, "senderConfusesRTN", isLocked(SCRTN), senderConfusesRTN);
     putDecimal(buf, "senderDataSent", isLocked(SDS), senderDataSent);
     putDecimal(buf, "senderDataSent1", isLocked(SDS), senderDataSent1);
     putDecimal(buf, "senderDataSent2", isLocked(SDS), senderDataSent2);
diff --git a/faxd/FaxMachineInfo.h b/faxd/FaxMachineInfo.h
index 91d258b..4687cbe 100644
--- a/faxd/FaxMachineInfo.h
+++ b/faxd/FaxMachineInfo.h
@@ -56,6 +56,7 @@ private:
     bool	hasV17Trouble;		// has difficulty with V.17
     bool	senderHasV17Trouble;	// sender has difficulty with V.17
     bool	senderSkipsV29;		// sender skips over V.29 usage
+    bool	senderConfusesRTN;	// sender misbehaves with RTN
     u_int	senderDataSent;		// amount of session data sent by sender
     u_int	senderDataSent1;	// amount of previous session data sent by sender
     u_int	senderDataSent2;	// amount of previous, previous session data sent by sender
@@ -114,6 +115,7 @@ public:
     bool getHasV17Trouble() const;
     bool getSenderHasV17Trouble() const;
     bool getSenderSkipsV29() const;
+    bool getSenderConfusesRTN() const;
     int getSenderDataSent() const;
     int getSenderDataSent1() const;
     int getSenderDataSent2() const;
@@ -150,6 +152,7 @@ public:
     void setHasV17Trouble(bool);
     void setSenderHasV17Trouble(bool);
     void setSenderSkipsV29(bool);
+    void setSenderConfusesRTN(bool);
     void setSenderDataSent(int);
     void setSenderDataSent1(int);
     void setSenderDataSent2(int);
@@ -200,6 +203,8 @@ inline bool FaxMachineInfo::getSenderHasV17Trouble() const
     { return senderHasV17Trouble; }
 inline bool FaxMachineInfo::getSenderSkipsV29() const
     { return senderSkipsV29; }
+inline bool FaxMachineInfo::getSenderConfusesRTN() const
+    { return senderConfusesRTN; }
 inline int FaxMachineInfo::getSenderDataSent() const
     { return senderDataSent; }
 inline int FaxMachineInfo::getSenderDataSent1() const
diff --git a/faxd/FaxModem.h b/faxd/FaxModem.h
index 775a615..b861032 100644
--- a/faxd/FaxModem.h
+++ b/faxd/FaxModem.h
@@ -45,8 +45,10 @@ class FaxServer;
 //     if there were a portable way to refer to them!
 typedef unsigned int RTNHandling;       // RTN signal handling method 
 typedef unsigned int BadPageHandling;	// bad page (received) handling method 
+typedef unsigned int MissedPageHandling;// missed page (received) handling method 
 typedef unsigned int JBIGSupport;	// JBIG support available
 typedef struct {
+    bool	senderConfusesRTN;	// if sender misbehaves with RTN
     bool	senderSkipsV29;		// if sender skips V.29 usage
     bool	senderHasV17Trouble;	// if we have trouble understanding sender's V.17
     int		senderDataSent;		// how much data the sender transmitted
@@ -203,6 +205,11 @@ public:
 	BADPAGE_DCN     = 1,	// send DCN, expect a disconnection
 	BADPAGE_RTNSAVE = 2	// send RTN, but save the page
     };
+    enum {			// FaxModem::MissedPageHandling
+	MISSEDPAGE_RTN  = 0,	// send RTN, expect a retransmission from Phase B
+	MISSEDPAGE_DCN  = 1,	// send DCN, expect a disconnection
+	MISSEDPAGE_CFR  = 2	// send CFR, expect a retransmission from Phase C
+    };
     enum {			// FaxModem::JBIGSupport
 	JBIG_NONE = 0,		    // no JBIG support
 	JBIG_RECV = 1,		    // receive-only JBIG support
diff --git a/faxd/FaxRecv.c++ b/faxd/FaxRecv.c++
index 679c491..7e121a1 100644
--- a/faxd/FaxRecv.c++
+++ b/faxd/FaxRecv.c++
@@ -55,6 +55,7 @@ FaxServer::recvFax(const CallID& callid, FaxMachineInfo clientInfo, fxStr& emsg)
     waitNotifyPid = 0;
 
     FaxSetup setupinfo;
+    setupinfo.senderConfusesRTN = clientInfo.getSenderConfusesRTN();
     setupinfo.senderSkipsV29 = clientInfo.getSenderSkipsV29();
     setupinfo.senderHasV17Trouble = clientInfo.getSenderHasV17Trouble();
     setupinfo.senderDataSent = clientInfo.getSenderDataSent() + clientInfo.getSenderDataSent1() + clientInfo.getSenderDataSent2();
@@ -109,6 +110,7 @@ FaxServer::recvFax(const CallID& callid, FaxMachineInfo clientInfo, fxStr& emsg)
     } else
 	traceServer("RECV FAX: %s", (const char*) emsg);
 
+    clientInfo.setSenderConfusesRTN(setupinfo.senderConfusesRTN);
     clientInfo.setSenderSkipsV29(setupinfo.senderSkipsV29);
     clientInfo.setSenderHasV17Trouble(setupinfo.senderHasV17Trouble);
     clientInfo.setSenderDataSent2(clientInfo.getSenderDataSent1());
diff --git a/faxd/ModemConfig.c++ b/faxd/ModemConfig.c++
index 7e863a0..b0e429b 100644
--- a/faxd/ModemConfig.c++
+++ b/faxd/ModemConfig.c++
@@ -314,6 +314,7 @@ ModemConfig::setupConfig()
     recvDataFormat	= DF_ALL;		// default to no transcoding
     rtnHandling         = FaxModem::RTN_RETRANSMITIGNORE; // retransmit until MCF/MPS
     badPageHandling	= FaxModem::BADPAGE_RTNSAVE; // send RTN but save the page
+    missedPageHandling	= FaxModem::MISSEDPAGE_RTN;
     answerAgainCmd	= parseATCmd("<delay:50>ATA");
 
     idConfig.resize(0);
@@ -636,6 +637,20 @@ ModemConfig::getBadPageHandling(const char* cp)
     return (bph);
 }
 
+u_int
+ModemConfig::getMissedPageHandling(const char* cp)
+{
+    MissedPageHandling mph;
+    if (valeq(cp, "RTN")) {
+	mph = FaxModem::MISSEDPAGE_RTN;
+    } else if (valeq(cp, "CFR")) {
+	mph = FaxModem::MISSEDPAGE_CFR;
+    } else {
+	mph = FaxModem::MISSEDPAGE_DCN;
+    }
+    return (mph);
+}
+
 u_int
 ModemConfig::getJBIGSupport(const char* cp)
 {
@@ -779,6 +794,8 @@ ModemConfig::setConfigItem(const char* tag, const char* value)
         answerAgainCmd = parseATCmd(value);
     else if (streq(tag, "badpagehandlingmethod"))
         badPageHandling = getBadPageHandling(value);
+    else if (streq(tag, "missedpagehandlingmethod"))
+        missedPageHandling = getMissedPageHandling(value);
     else if (streq(tag, "class2ecmtype"))
 	class2ECMType = getECMType(value);
     else if (streq(tag, "distinctiverings"))
diff --git a/faxd/ModemConfig.h b/faxd/ModemConfig.h
index a1ccca3..5fc8dce 100644
--- a/faxd/ModemConfig.h
+++ b/faxd/ModemConfig.h
@@ -63,6 +63,7 @@ private:
     u_int	getDataFormat(const char* value);
     u_int       getRTNHandling(const char* cp);
     u_int       getBadPageHandling(const char* cp);
+    u_int       getMissedPageHandling(const char* cp);
     u_int       getJBIGSupport(const char* cp);
     ECMType	getECMType(const char* cp);
 
@@ -261,6 +262,7 @@ public:
 
     RTNHandling rtnHandling;            // RTN signal handling method
     BadPageHandling badPageHandling;	// bad page (received) handling method
+    MissedPageHandling missedPageHandling;	// missed page (received) handling method
     JBIGSupport	class1JBIGSupport;	// monochrome JBIG support
     JBIGSupport	class2JBIGSupport;	// monochrome JBIG support
     bool	saveUnconfirmedPages;	// don't delete unconfirmed pages
diff --git a/man/hylafax-config.4f b/man/hylafax-config.4f
index f8eec90..0bdb537 100644
--- a/man/hylafax-config.4f
+++ b/man/hylafax-config.4f
@@ -186,6 +186,7 @@ MaxSetupAttempts	integer	\s-12\s+1	max attempts to initialize a modem
 MaxTraversal¹	integer	256	max traversal into queue for batching
 MaxTries¹	integer	\s-13\s+1	max attempts to transmit a job
 MinAcceptedLineCount	integer	\s-110\s+1	min number of rows for \s-1OK\s+1 page quality
+MissedPageHandlingMethod	string	\s-1RTN\s+1	missed page received handling method	
 ModemGroup¹	string	\-	define a name for a set of modems
 ModemPriority	integer	255	scheduling priority for outbound jobs
 ModemReadyState	string	\s-1R\s+1	``ready state'' sent by \fIfaxgetty\fP
@@ -784,6 +785,7 @@ process to utilize an associated entry in the info database for
 items such as
 .BR senderDataSent ,
 .BR senderDataMissed ,
+.BR senderConfusesRTN ,
 .BR senderHasV17Trouble ,
 and
 .BR senderSkipsV29 .
@@ -1308,6 +1310,39 @@ The minimum number of received scanlines allowed on an ``OK'' page.
 The use of this setting prevents confirmation from being sent for
 very short pages.
 .TP
+.B MissedPageHandlingMethod
+(Class 1/1.0 only) Specifies how to react to a missed page received from the remote sender:
+one of ``\s-1RTN\s+1'', ``\s-1DCN\s+1'', or ``\s-1CFR\s+1''.
+
+If a page is missed (where the modem does not train on the Phase C carrier) in non-ECM mode
+then, like
+.BR BadPageHandlingMethod ,
+it can be somewhat difficult to inform the sender of the problem.
+
+A setting of ``\s-1RTN\s+1'' is the proper behavior that fax protocol employs
+to request that the sender retransmit the page after retraining.  Unfortunately, however,
+some senders will perceive this as a receipt confirmation and not retransmit the page.
+
+A setting of ``\s-1DCN\s+1'' should trigger a call abortion by
+the sender.  This should clearly indicate a problem to the sender,
+although a retransmission attempt in a later
+call cannot be guaranteed.
+
+A setting of ``\s-1CFR\s+1'' causes an out-of-spec behavior where the CFR signal
+is used in response to the post-page message.  While other \*(Fx senders should handle
+this signal to lead to a retransmision of the page without retraining, most senders
+will disconnect after receiving this signal as it is not a permitted response in Phase D.
+
+Historically, \*(Fx has employed both ``\s-1RTN\s+1'' and ``\s-1DCN\s+1'' behaviors
+by default with complaints using either.  The ``\s-1CFR\s+1'' behavior was
+developed in order to evaluate if other systems besides \*(Fx would tolerate it, and
+that did not produce promising results.  So,
+.BR MissedPageHandlingMethod
+is designed to allow the administrator the opportunity to vary between these options
+through the
+.BR DynamicConfig
+feature to acheive a more nuanced approach.
+.TP
 .B ModemGroup¹
 Define a logical name for a set of modem devices.
 This parameter can be used to define a name that clients can use
diff --git a/man/hylafax-info.4f b/man/hylafax-info.4f
index 08015c3..39913e3 100644
--- a/man/hylafax-info.4f
+++ b/man/hylafax-info.4f
@@ -90,6 +90,7 @@ dataSent2	number	units of data sent to the destination in the session previous,
 dataMissed	number	units of data sent to the destination which were missed or corrupt in the last session
 dataMissed1	number	units of data sent to the destination which were missed or corrupt in session previous to the last
 dataMissed2	number	units of data sent to the destination which were missed or corrupt in session previous, previous to the last
+senderConfusesRTN	boolean	this caller does not return to Phase B and resend the same page after RTN
 senderDataSent	number	units of data sent by the sender in the last session
 senderDataSent1	number	units of data sent by the sender in the session previous to the last
 senderDataSent2	number	units of data sent by the sender in the session previous, previous to the last
